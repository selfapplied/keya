"""
Test that the emergent base system from operators can perform actual arithmetic.

This verifies that the 2x2 patterns generated by resonance can represent
numbers and perform correct arithmetic operations.
"""




import jax.numpy as jnp

from keya.core.operators import (
    C_operator,
    D_operator,
    Glyph,
    binary_number_to_matrix,
    create_glyph_matrix,
    matrix_binary_add,
    matrix_binary_multiply,
    matrix_to_binary_number,
    verify_base_emergence,
)


def print_matrix(matrix: jnp.ndarray, title: str):
    """Print a glyph matrix with readable symbols."""
    print(f"\n{title}:")
    symbols = {
        Glyph.VOID.value: "‚àÖ",
        Glyph.DOWN.value: "‚ñΩ", 
        Glyph.UP.value: "‚ñ≥",
        Glyph.UNITY.value: "‚äô",
        Glyph.FLOW.value: "‚äï"
    }
    
    for row in matrix:
        row_str = " ".join(symbols.get(int(val), "?") for val in row)
        print(f"  {row_str}")

def test_number_representation():
    """Test that numbers can be represented in matrix form."""
    print("=== TESTING NUMBER REPRESENTATION ===")
    
    # Test small numbers
    for num in [0, 1, 3, 5, 7]:
        matrix = binary_number_to_matrix(num, 3, 4)
        decoded = matrix_to_binary_number(matrix)
        
        print(f"\nNumber {num} (binary: {bin(num)}):")
        print_matrix(matrix, "Matrix representation")
        print(f"Decoded back to: {decoded}")
        
        assert decoded == num, f"Failed to represent {num}: got {decoded}"
    
    print("‚úÖ Number representation works correctly")

def test_matrix_arithmetic():
    """Test that matrices can perform actual arithmetic."""
    print("\n=== TESTING MATRIX ARITHMETIC ===")
    
    # Test addition: 3 + 5 = 8
    matrix_3 = binary_number_to_matrix(3, 3, 4)
    matrix_5 = binary_number_to_matrix(5, 3, 4)
    
    print_matrix(matrix_3, "Matrix for 3")
    print_matrix(matrix_5, "Matrix for 5")
    
    result_add = matrix_binary_add(matrix_3, matrix_5)
    computed_sum = matrix_to_binary_number(result_add)
    
    print_matrix(result_add, "3 + 5 result")
    print(f"Computed sum: {computed_sum}")
    
    assert computed_sum == 8, f"Addition failed: 3 + 5 = {computed_sum}, expected 8"
    print("‚úÖ Matrix addition works correctly")
    
    # Test multiplication: 3 * 4 = 12
    matrix_4 = binary_number_to_matrix(4, 3, 4)
    result_mult = matrix_binary_multiply(matrix_3, matrix_4)
    computed_product = matrix_to_binary_number(result_mult)
    
    print_matrix(result_mult, "3 * 4 result")
    print(f"Computed product: {computed_product}")
    
    assert computed_product == 12, f"Multiplication failed: 3 * 4 = {computed_product}, expected 12"
    print("‚úÖ Matrix multiplication works correctly")

def test_dc_generated_arithmetic():
    """Test arithmetic using patterns generated by actual operators."""
    print("\n=== TESTING GENERATED ARITHMETIC ===")
    
    # Start with uniform field and apply to get binary patterns
    uniform_field = create_glyph_matrix((4, 4), Glyph.VOID)
    dissonant = D_operator(uniform_field)
    binary_pattern = C_operator(dissonant, "binary")
    
    print_matrix(uniform_field, "Initial uniform field")
    print_matrix(dissonant, "After D operator")
    print_matrix(binary_pattern, "After C operator (binary pattern)")
    
    # Try to interpret this pattern as a number
    pattern_value = matrix_to_binary_number(binary_pattern)
    print(f"generated pattern represents number: {pattern_value}")
    
    # Test that we can do arithmetic with generated patterns
    # Create another pattern and add them
    uniform_field2 = create_glyph_matrix((4, 4), Glyph.DOWN)
    binary_pattern2 = C_operator(uniform_field2, "binary")
    pattern_value2 = matrix_to_binary_number(binary_pattern2)
    
    print_matrix(binary_pattern2, "Second pattern")
    print(f"Second pattern represents: {pattern_value2}")
    
    # Add the patterns
    sum_pattern = matrix_binary_add(binary_pattern, binary_pattern2)
    sum_value = matrix_to_binary_number(sum_pattern)
    expected_sum = pattern_value + pattern_value2
    
    print_matrix(sum_pattern, "Sum of patterns")
    print(f"Sum: {pattern_value} + {pattern_value2} = {sum_value}")
    print(f"Expected: {expected_sum}")
    
    assert sum_value == expected_sum, "pattern arithmetic failed"
    print("‚úÖ generated patterns can perform arithmetic")

def test_comprehensive_verification():
    """Run the comprehensive verification function."""
    print("\n=== COMPREHENSIVE VERIFICATION ===")
    
    success = verify_base_emergence(test_size=4)
    assert success, "Comprehensive verification failed"
    print("‚úÖ All comprehensive tests passed")

def test_edge_cases():
    """Test edge cases and boundaries."""
    print("\n=== TESTING EDGE CASES ===")
    
    # Test zero
    matrix_0 = binary_number_to_matrix(0, 2, 3)
    decoded_0 = matrix_to_binary_number(matrix_0)
    assert decoded_0 == 0, "Zero representation failed"
    
    # Test powers of 2
    for power in range(4):
        num = 2 ** power
        matrix = binary_number_to_matrix(num, 3, 4)
        decoded = matrix_to_binary_number(matrix)
        assert decoded == num, f"Power of 2 test failed for 2^{power}"
    
    print("‚úÖ Edge cases pass")

if __name__ == "__main__":
    print("Testing emergent base system arithmetic...")
    print("Verifying that operators can generate working number systems.\n")
    
    try:
        test_number_representation()
        test_matrix_arithmetic() 
        test_dc_generated_arithmetic()
        test_comprehensive_verification()
        test_edge_cases()
        
        print("\nüéâ ALL TESTS PASSED!")
        print("‚úÖ Base system emergence is verified and working")
        print("‚úÖ operators generate functional arithmetic systems")
        print("‚úÖ Mathematical claim substantiated with rigorous testing")
        
    except AssertionError as e:
        print(f"\n‚ùå TEST FAILED: {e}")
        print("The base system emergence needs further work.")
    except Exception as e:
        print(f"\nüî• UNEXPECTED ERROR: {e}")
        print("Implementation has bugs that need fixing.") 